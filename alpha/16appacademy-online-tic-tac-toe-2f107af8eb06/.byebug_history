continue
move
next 5
return
next
move[0].length
move
quit
continue
name
board
@mark
mark
quit
board
@mark
mark
return
turn
reutnr
continue
mark
@mark
op_mark
self.mark
:mark
@mark
mark
board.winner == mark
board.winner
move
board
next 5
move
board
continue
board
return
continue
grid
puts line.map{|n| n||= " "}.join("|")
line = [nil, :X, nil]
puts line.map{|n| n||= " "}.join("|")
   18:       puts line.map{|n| n||= " "}.join("|")
line = grid[0]
grid
next 
next 5
next
grid
next
grid
mext
grid
grud
continue
prev
board
next
board
next
board
next
board
continue
Board.new
board
move[0]
continue
next
is_over
next
return
continue
b1
b1.place_mark [0,0], nil
b1
b1.place_mark [0,0], :X
b1 = Board.new
b1 = board.new
board
board.place_mark [0,0], :X
board.place_mark [0,0] :X
Board.new
board.grid
board.winner
board.over?
board
next
continue
next
game
board
continue
@board = g.board
g.board
g
board
g = new(human, cpu)
human
@board
board
continue
new_grid
grid[0][0] = :D
new_grid = grid.dup.clone
new_grid
grid
grid[0][0] = :XC
new_grid = grid.clone.clone
new_grid
grid
grid[0][0] = :X
grid
new_grid
quit
test_board
board.grid
test_grid
move
test_grid
next
move
test_grid
quit
test_grid
board
quit
boardquit
board
next
board
move
next
winner
move
board
next
move
board
move
board
next
move
board
next
board
quit
board
next
nezt
board
move
next
board
bord
quit
board
winner
move
next
next move
move
next
move
next
winner
move
next
move
next
available
move
test_board
quit
test_board.place_mark([0,0] , :X)quit
test_board.place_mark([0,0] , :X)
test_board.winner
test_board = Board.new
test_board.winner
test_board
test_board.board
test_board.place_mark(0, :mark)
test_board.place_mark([2,0], :mark)
test_board.place_mark[2,0], :mark
test_board.place_mark[2,0], :mark)
test_board.place_mark[2,0]
test_board
quit
available
move
board
next
board
next
board
move
quit
available
move
mpve
next
    available = arr.each_index.select.with_index { |n, idx| arr[idx] == nil}
    arr = board.grid.flatten
available
board
available
temp
winner
next
winner
board
next
board
skip
next
board.grid
board
quit
        horiz || vert
        vert = combo.all?{|square| grid[square[1]][square[0]] == mark}
      horiz = combo.all?{|square| grid[square[0]][square[1]] == mark}
combo = [[0,2],[2,2],[2,0]]
grid
return
        horiz || vert
        vert = combo.all?{|square| grid[square[1]][square[0]] == mark}
  horiz = combo.all?{|square| grid[square[0]][square[1]] == mark}
combo = [[0,0],[1,1],[2,2]]
grid
return
grid
next 10
grid
next 5
grid
next
[[0,0],[0,1],[0,2]].all?{|square| grid[square[0]][square[1]] == mark}
grid
[[0,2],[2,2],[2,0]].all?{|square| grid[square[0]][square[1]] == mark}
[[0,2],[2,2],[2,0]].all?{|square| grid[square[0]][square[1]] == mark
quit
continuequit
continue
next
quit
out
skip
return
continue
      end
        combo.all?{|square| grid[square[1]][square[0]] == mark}
        combo.all?{|square| grid[square[0]][square[1]] == mark} ||
is_winner = winning_combos.any? do |combo|
      end
        combo.all?{|square| grid[square[1]][square[0]] == mark}
